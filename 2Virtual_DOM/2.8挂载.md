# 2.8 挂载
经过前面的铺垫，终于到了挂载这一步了。前面的步骤中，到ReactCompositeComponent.mountComponent入口了。大家能够看出来吗？下面我们就开始详细地分析这个函数，弄清楚挂载的具体流程。
componentMount方法是我们真个系列中最重要的部分。如果对`2.1创建节点`还记得，那么我们应该知道，传入mountComponent的入口组件：组件树的入口组件是`TopLevelWrapper`组件(React底层内部类)。我们准备挂载它。由于它实际上是一个空的包装器，调用起来非常枯燥，并且对实际流程没有任何影响，因此跳过这个组件从它的child组件开始分析。
把组件挂在到组件树上的过程就是先挂在父组件，然后是它的孩子组件，然后是它孩子的孩子组件，一层一层地以此类推。当然可以肯定的是：当TopLevelWrapper挂载后，他的孩子组件(用来管理User的组件的ReactCompositeComponent)也会在同一时间注入。
## 2.8.1 给实例赋值updater
从transaction.getUpdateQueue()方法中返回的updater,实际就是UpdateQueue模块。为什么在这里赋值updater呢？因为我们正在研究的类ReactCompositeComponent是一个全平台的公用的类，但是updater却依赖于平台有不同的实现，所以这里我们根据不同平台动态地将它赋值给实例。
并且我们并不是马上需要updater,但是我们需要记住它非常重要，因为它很快会应用在非常知名的组件内更新方法的setState。
事实上，这个过程不仅仅给updater赋值，组件实例(自定义的组件)也获得了继承的props,context和refs.
```javascript
// 传入组件ReactComponent的第三个参数updater。默认是ReactUpdateQueue模块，用于实现setState等方法  
var updateQueue = transaction.getUpdateQueue();
```
## 2.8.2 创建<User />
在我们的例子中，这里终于调用了User的构造函数，创建了一个实例对象返回，并放到inst对象中。
```javascript
var ReactCompositeComponent = {
    // 创建纯组件或者组件实例，或者获取无状态组件的返回值
    mountComponent: function(xxx) {
        ...
        var inst = this._constructComponent(
            doConstruct,
            publicProps,
            publicContext,
            updateQueue
        );
        ...
    },
    _constructComponent: function(xxx){
        this._constructComponentWithoutOwner(
            doConstruct,
            publicProps,
            publicContext,
            updateQueue
        );
    },
    _constructComponentWithoutOwner: function(xxx) {
        // 获取组件的构造函数或类
        var Component = this._currentElement.type;
        ...
        // Component为纯组件或组件，创建实例
        return new Component(xxx);
    }
};
} 
```
## 2.8.3 执行首次挂载
当执行挂在的时候，我们在mountComponent方法中可以看到，首先发生的行为就是：componentWillMount()方法的调用。这是生命周期函数中的第一个钩子函数。下面还有要给componentDidMount钩子函数，但是它不能立马执行，而是加入到了事务队列中，在最后挂载完成后执行。
当然，也可以在componentWillMount()方法中，内部调用setState方法，但是这种请看下state会被重新计算，但是不会调用render。这是合理的，因为componentWillMount方法在render之前调用，此时组件还没有被挂在。因此在这个过程中设置state不会触发重绘。但是当state被重新计算完成后，会调用我们在组件声明的render方法。
```javascript
var ReactCompositeComponent = {
    mountComponent: function(xxx) {
        ...
        markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
        ....
         // 将componentDidMount加入事物队列
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
    },
    },
    // 创建纯组件或者组件实例，或者获取无状态组件的返回值
    performInitialMount: function(xxx) {
        ...
       if (inst.componentWillMount) {
            //..
            inst.componentWillMount();
            // 当挂载时, 在 `componentWillMount` 中调用的 `setState` 会执行并改变状态
            // `this._pendingStateQueue` 不会触发重渲染
            if (this._pendingStateQueue) {
                inst.state = this._processPendingState(inst.props, inst.context);
            }
        }
        ...
       
    }
} 
```
接下来，我们就会创建一个React的组件的实例。看下面的挂在源码分析：
-  renderedElement = this._renderValidatedComponent()： 返回的就是render()方法执行结果,返回ReactElement元素。
- this._instantiateReactComponent(renderedElement,..): 将我们对象转换为ReactCompositeComponent || ReactDOMComponent,ReactDOMTextComponent,基于render()方法获得的元素座位它的孩子创建VDOM(虚拟DOM)的实例。该实例被创建后，我们会再次调用ReactRecoclier.mountComponent，但是这次传入的时刚刚创建的ReactDOMComponent实例作为internalInstance。
只要有child属性，那么就一直递归进行下去，直到所有的元素全被解析，最后生成DOMLazyTree对象，其node属性为需要插入文档dom对象。
```javascript
var ReactCompositeComponent = {
    performInitialMount: function(xxx) {
        ...
        inst.componentWillMount();
        ...
        // 间接执行ReactClass或TopLevelWrapper实例的render方法，获取待挂载的元素ReactNode  
        // 组件若为函数式无状态组件function(props,context,updateQueue){}，renderedElement由传参提供
        if (renderedElement === undefined) {
            renderedElement = this._renderValidatedComponent();
        }
        // 节点类型，ReactComponentElement元素返回1；ReactDomElement元素返回0；若为空，返回2
        var nodeType = ReactNodeTypes.getType(renderedElement);
        this._renderedNodeType = nodeType;
        // 调用instantiateReactComponent模块以实例化render方法的返回值，即renderedElement元素  
        var child = this._instantiateReactComponent(
            renderedElement,
            nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
        );
        // render方法内子组件实例 
        this._renderedComponent = child;
        // 嵌套调用mountComponent，完成renderedElement元素相应组件的实例化及render方法执行  
        // 最终通过ReactDomElement转化为DOMLazyTree对象输出，其node属性为需要插入文档dom对象  
        var markup = ReactReconciler.mountComponent(
            child,
            transaction,
            hostParent,
            hostContainerInfo,
            this._processChildContext(context),
            debugID
        );
    },
    _renderValidatedComponent: function(xx) {
        ...
        renderedElement =this._renderValidatedComponentWithoutOwnerOrContext();
    },
    // 可以看出，实际就是返回实例的render方法的调用结果
    _renderValidatedComponentWithoutOwnerOrContext: function() {
        var inst = this._instance;
        var renderedElement;
        renderedElement = inst.render();
    }
} 
```
## 2.8.5 首次挂在流程图
![](/image/12.png)

## 2.8.6 子元素挂载
上面的挂载中，整体都是挂在一个ComponentCompositeComponent